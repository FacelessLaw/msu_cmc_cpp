1.
Ошибки:
    21 строчка "b.z" и "-b.z" - доступ и изменение приватного поля
    44 строчка "B b1" - у класса отсутствует конструктор по умолчанию
    45 строчка "const B b" - у класса отсутствует конструктор по умолчанию
    47 строчка "dynamic_cast<B*>(pa1)" pa1 - объект класса А, не являющегося полиморфным с B
    51 строчка "b.w++" - выражение не является допустимым для изменения, т.к. "b" есть "const B", значение w
    51 строчка "b.g()" - попытка вызвать неконстантный метод через константный объект
    52 строчка "throw *pa" - будет задействован приватный оператор копирования
Вывод:
    nnn::f 
    1
    0
    555
    error AAA
Исправления(соответсвуют порядку следования ошибок):
    добавить в B "friend B& operator- (B& b);"
    исправить конструктор в B на "B (int b = 0) { z = b; }"
    добавить виртуальный деструктор в А "virtual ~A() = default;"
    сделать поле w в B static, присвоить значение "int B::w = 0;"
    сделать функцию g() const
    написать ещё конструкторы копирования в А и В в публичной части

2.
    https://pastebin.com/xxQ6vuvA - ссылка на код.

3.
    Алгоритмы STL (их всего 60) - реализуют некоторые распространенные операции с контейнерами,
    которые не представлены функциями-членами каждого из контейнеров 
    (например, просмотр, сортировка, поиск, удаление элементов…).

    Реализация алгоритмов не использует имен никаких конкретных
    контейнеров, а все действия над контейнером производятся
    через универсальные имена итераторов.

    По соглашению, при описании алгоритмов, входящих в STL, используются стандартные имена 
    формальных параметров-итераторов. В зависимости от названия итератора в прототипе алгоритма,
    должен использоваться итератор уровня «не ниже чем». То есть по названию параметров 
    шаблона можно понять, какого рода итератор нам нужен, то есть к какому контейнеру 
    применим этот алгоритм.